#!/usr/bin/env node

const app = require("../app");
const debug = require("debug")("kepuch:server");
const http = require("http");
const { Server } = require("socket.io");
const axios = require("axios"); // Import axios
const { getFlowrateData, getRssiData, getStatisticsData } = require("../routes/index");
require("dotenv").config(); // Pastikan dotenv di-load

const port = normalizePort(process.env.PORT || "3000");
app.set("port", port);

const server = http.createServer(app);

// --- Konfigurasi Blynk ---
// Menggunakan 1 token dengan virtual pin berbeda untuk setiap masjid
const BLYNK_AUTH_TOKEN = process.env.BLYNK_AUTH_TOKEN; // Satu token untuk semua kontroler

// FIXED: Hardcode URL untuk memastikan tidak ada override
const BLYNK_API_URL = "https://blynk.cloud/external/api"; // NO TRAILING SLASH!

// Mapping virtual pin untuk setiap masjid
const VIRTUAL_PIN_MAPPING = {
	node1: "v0", // V0 = Masjid 1
	node2: "v1", // V1 = Masjid 2
	node3: "v2", // V2 = Masjid 3
};

// --- Setup WebSocket (Socket.io) ---
const io = new Server(server, {
	cors: {
		origin: "*", // Sesuaikan untuk produksi
		methods: ["GET", "POST"],
	},
});

io.on("connection", (socket) => {
	console.log("Client terhubung:", socket.id);

	// Event handler untuk kontrol pompa
	socket.on("pipe:control", async (data) => {
		const { nodeId, action } = data;

		// Cek apakah token tersedia
		if (!BLYNK_AUTH_TOKEN) {
			socket.emit("pipe:control:feedback", {
				status: "error",
				message: "Konfigurasi Blynk belum diatur. Cek BLYNK_AUTH_TOKEN.",
			});
			return;
		}

		// Cek apakah nodeId valid dan dapatkan virtual pin
		const virtualPin = VIRTUAL_PIN_MAPPING[nodeId];
		if (!virtualPin) {
			socket.emit("pipe:control:feedback", {
				status: "error",
				message: `Node ${nodeId} tidak terdaftar dalam sistem.`,
			});
			return;
		}

		// Tentukan nilai (1 untuk OPEN, 0 untuk CLOSE)
		const value = action.toUpperCase() === "OPEN" ? 1 : 0;

		try {
			// FIXED: Pastikan URL dibentuk dengan benar
			const blynkUrl = `${BLYNK_API_URL}/update?token=${BLYNK_AUTH_TOKEN}&${virtualPin}=${value}`;

			const response = await axios.get(blynkUrl, {
				timeout: 10000, // 10 second timeout
				headers: {
					"User-Agent": "Kepuh-Statistic/1.0",
				},
			});

			console.log(`✅ Perintah ke Blynk untuk ${nodeId} (${virtualPin.toUpperCase()}) berhasil dikirim: ${action} (${value})`);

			socket.emit("pipe:control:feedback", {
				nodeId: nodeId,
				action: action,
				status: "success",
				message: `Perintah ${action} untuk ${nodeId} berhasil dikirim via ${virtualPin.toUpperCase()}.`,
			});
		} catch (error) {
			console.error(`❌ Gagal mengirim perintah ke Blynk untuk ${nodeId}:`);
			console.error(`❌ Error details:`, {
				message: error.message,
				response: error.response
					? {
							status: error.response.status,
							statusText: error.response.statusText,
							data: error.response.data,
					  }
					: "No response",
				request: error.request ? "Request made but no response" : "Request not made",
			});

			const errorMessage = error.response?.data?.error?.message || error.message || "Unknown error";
			socket.emit("pipe:control:feedback", {
				nodeId: nodeId,
				action: action,
				status: "error",
				message: `Gagal mengirim perintah ${action} untuk ${nodeId}: ${errorMessage}`,
			});
		}
	});

	socket.on("disconnect", () => {
		console.log("Client terputus:", socket.id);
	});
});

// --- Real-time Data Broadcasting ---
let dataUpdateInterval;
let pumpStatusInterval;

// Function to get current pump status from Blynk
async function getPumpStatusFromBlynk() {
	const statuses = {};

	try {
		for (const [nodeId, virtualPin] of Object.entries(VIRTUAL_PIN_MAPPING)) {
			try {
				const blynkGetUrl = `${BLYNK_API_URL}/get?token=${BLYNK_AUTH_TOKEN}&${virtualPin}`;

				const response = await axios.get(blynkGetUrl, {
					timeout: 5000,
					headers: { "User-Agent": "Kepuh-Statistic/1.0" },
				});

				// Blynk returns array with the value, e.g., ["1"] for ON, ["0"] for OFF
				const value = Array.isArray(response.data) ? response.data[0] : response.data;
				const status = value === "1" || value === 1 ? "open" : "closed";
				statuses[nodeId] = status;
			} catch (error) {
				console.error(`❌ Failed to get status for ${nodeId}:`, error.message);
				statuses[nodeId] = "unknown";
			}
		}
	} catch (error) {
		console.error("❌ Error polling pump status from Blynk:", error.message);
	}

	return statuses;
}

// Function to broadcast pump status updates to all clients
async function broadcastPumpStatusUpdates() {
	try {
		const clientCount = io.sockets.sockets.size;
		if (clientCount === 0) {
			return;
		}

		const pumpStatuses = await getPumpStatusFromBlynk();

		// Send updated status to all clients
		io.emit("pump:status:update", {
			timestamp: new Date(),
			statuses: pumpStatuses,
		});
	} catch (error) {
		console.error("❌ Error broadcasting pump status updates:", error.message);
	}
}

// Function to broadcast fresh data to all connected clients
async function broadcastDataUpdates() {
	try {
		const clientCount = io.sockets.sockets.size;
		if (clientCount === 0) {
			return;
		}

		// Get fresh data from database
		const [flowrateData, rssiData, statisticsData] = await Promise.all([getFlowrateData(), getRssiData(), getStatisticsData()]);

		// Broadcast a single unified event
		io.emit("data:update", {
			flowrate: flowrateData,
			rssi: rssiData,
			statistics: statisticsData,
		});
	} catch (err) {
		console.error("Error broadcasting data updates:", err);
	}
}

// Start periodic data broadcasting every 30 seconds
function startDataBroadcasting() {
	// Initial broadcast
	setTimeout(broadcastDataUpdates, 2000); // Wait 2 seconds after server start

	// Set up periodic broadcasting every 10 seconds (more frequent for better real-time experience)
	dataUpdateInterval = setInterval(broadcastDataUpdates, 10000);
}

// Start periodic pump status polling
function startPumpStatusPolling() {
	// Initial poll after 3 seconds
	setTimeout(broadcastPumpStatusUpdates, 3000);

	// Set up periodic polling every 15 seconds
	pumpStatusInterval = setInterval(broadcastPumpStatusUpdates, 15000);
}

// Stop data broadcasting (useful for cleanup)
function stopDataBroadcasting() {
	if (dataUpdateInterval) {
		clearInterval(dataUpdateInterval);
		dataUpdateInterval = null;
	}

	if (pumpStatusInterval) {
		clearInterval(pumpStatusInterval);
		pumpStatusInterval = null;
	}
}

server.listen(port);
server.on("error", onError);
server.on("listening", onListening);

function normalizePort(val) {
	const port = parseInt(val, 10);
	if (isNaN(port)) return val;
	if (port >= 0) return port;
	return false;
}

function onError(error) {
	if (error.syscall !== "listen") throw error;
	const bind = typeof port === "string" ? "Pipe " + port : "Port " + port;
	switch (error.code) {
		case "EACCES":
			console.error(bind + " requires elevated privileges");
			process.exit(1);
			break;
		case "EADDRINUSE":
			console.error(bind + " is already in use");
			process.exit(1);
			break;
		default:
			throw error;
	}
}

function onListening() {
	const addr = server.address();
	const bind = typeof addr === "string" ? "pipe " + addr : "port " + addr.port;
	debug("Listening on " + bind);
	console.log("Server is listening on " + bind);

	// Blynk Configuration Validation
	console.log("\n🔧 Blynk Configuration Check:");
	if (BLYNK_AUTH_TOKEN) {
		console.log(`✅ Token: ${BLYNK_AUTH_TOKEN.substring(0, 8)}... (${BLYNK_AUTH_TOKEN.length} chars)`);
		console.log(`✅ API URL: ${BLYNK_API_URL}`);
		console.log("✅ Virtual Pin Mapping:");
		Object.entries(VIRTUAL_PIN_MAPPING).forEach(([node, pin]) => {
			console.log(`   ${node} → ${pin.toUpperCase()}`);
		});

		// Test Blynk connectivity
		testBlynkConnection();
	} else {
		console.error("❌ BLYNK_AUTH_TOKEN tidak ditemukan!");
		console.error("❌ Kontrol pompa tidak akan berfungsi!");
	}

	// Start real-time data broadcasting
	startDataBroadcasting();

	// Start pump status polling
	startPumpStatusPolling();
}

// Function to test Blynk connection on startup
async function testBlynkConnection() {
	try {
		// Test dengan virtual pin V0 (node1)
		const testUrl = `${BLYNK_API_URL}/get?token=${BLYNK_AUTH_TOKEN}&v0`;
		const response = await axios.get(testUrl, { timeout: 5000 });

		console.log(`✅ Blynk connectivity test passed!`);
	} catch (error) {
		console.error("❌ Blynk connectivity test failed!");
		console.error("❌ Error:", error.response?.data || error.message);
		console.error("❌ Please check your BLYNK_AUTH_TOKEN and internet connection");
	}
}

// Graceful shutdown handling
process.on("SIGTERM", () => {
	console.log("SIGTERM received, shutting down gracefully...");
	stopDataBroadcasting();
	server.close(() => {
		console.log("HTTP server closed");
		process.exit(0);
	});
});

process.on("SIGINT", () => {
	console.log("SIGINT received, shutting down gracefully...");
	stopDataBroadcasting();
	server.close(() => {
		console.log("HTTP server closed");
		process.exit(0);
	});
});
